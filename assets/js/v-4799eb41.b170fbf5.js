"use strict";(self.webpackChunkfe_note=self.webpackChunkfe_note||[]).push([[1882],{2074:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-4799eb41",path:"/summary/js-base/scope.html",title:"作用域",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"词法作用域",slug:"词法作用域",children:[]},{level:2,title:"作用域链",slug:"作用域链",children:[]},{level:2,title:"延长作用域链",slug:"延长作用域链",children:[]},{level:2,title:"欺骗词法作用域",slug:"欺骗词法作用域",children:[]},{level:2,title:"参考",slug:"参考",children:[]}],filePathRelative:"summary/js-base/scope.md",git:{updatedTime:1637511382e3}}},9278:(n,s,a)=>{a.r(s),a.d(s,{default:()=>l});var p=a(6252);const e=(0,p.uE)('<h1 id="作用域" tabindex="-1"><a class="header-anchor" href="#作用域" aria-hidden="true">#</a> 作用域</h1><p>作用域是定义一个变量可访问区域。JS中在一个上下文的访问一个变量，会按照某种规则查找这个变量，这个规则我们成为作用域链。</p><h2 id="词法作用域" tabindex="-1"><a class="header-anchor" href="#词法作用域" aria-hidden="true">#</a> 词法作用域</h2><p>词法作用域(也称静态作用域)是指上下文中访问一个变量的查找顺序在它环境定义时就决定，与何时进入执行环境无关。比如下面的例子</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&#39;global&#39;</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&#39;run&#39;</span><span class="token punctuation">;</span>\n  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// global</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上面例子输出的结果是global而不是run。这就说明的foo()函数在查找str变量时候是根据函数定义时决定的，和函数的执行无关。</p><p>和静态作用域相对的是动态作用域，比如Perl语言.</p><h2 id="作用域链" tabindex="-1"><a class="header-anchor" href="#作用域链" aria-hidden="true">#</a> 作用域链</h2><p>函数执行时查找一个变量的值，会现在当前执行环境查找时候定义。如果没有定义，会去它的父执行上下文查找，向上查找直到全局环境。如果全局环境也找不到就会报错。这种定义一个变量的查询顺序的规则就叫作用域链。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Uncaught ReferenceError: b is not defined</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>我们知道函数声明时会创建变量对象(VO)，在函数执行时该对象激活变成活动对象(AO)。与此同时，函数创建时也会决定它的内部属性[[Scopes]]，值为声明它的上下文的[[Scopes]]。当函数执行的时候会把当前的执行上下文的活动对象压进[[Scopes]]的顶部。当查找一个变量时就会遍历[[Scopes]]的变量对象，这就是作用域链的内部机制。</p><h2 id="延长作用域链" tabindex="-1"><a class="header-anchor" href="#延长作用域链" aria-hidden="true">#</a> 延长作用域链</h2><p>在JS中创建一个函数才会对应的变量对象和作用域链，当在函数里面用with语句的时候，会把当前作用的对象加到函数作用域链的顶部，从而延长了作用域链：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  a<span class="token operator">:</span> <span class="token number">1</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1</span>\n    <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// hello</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>上面的代码看出，with里面声明的变量会加到最近的执行环境上。另外的try...catch语句的catch块也可以实现作用域链的延长。</p><h2 id="欺骗词法作用域" tabindex="-1"><a class="header-anchor" href="#欺骗词法作用域" aria-hidden="true">#</a> 欺骗词法作用域</h2><p>我们知道一个变量的访问规则是在函数书写就决定的，但是eval()函数插入的代码会破坏这一规则：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">&#39;a=2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面代码的函数的创建不会知道eval()里面的字符串代码，只是在执行的时候按照正常作用域链的查找顺序，根据就近原则，优先找到了a=2。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',20),t={href:"https://github.com/mqyqingfeng/Blog/issues/6",target:"_blank",rel:"noopener noreferrer"},c=(0,p.Uk)("JavaScript深入之作用域链"),o={},l=(0,a(3744).Z)(o,[["render",function(n,s){const a=(0,p.up)("OutboundLink");return(0,p.wg)(),(0,p.iD)(p.HY,null,[e,(0,p._)("p",null,[(0,p._)("a",t,[c,(0,p.Wm)(a)])])],64)}]])},3744:(n,s)=>{s.Z=(n,s)=>{for(const[a,p]of s)n[a]=p;return n}}}]);