"use strict";(self.webpackChunkfe_note=self.webpackChunkfe_note||[]).push([[1520],{6865:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-9e85341a",path:"/summary/js-advance/event-loop.html",title:"事件循环",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"一些术语",slug:"一些术语",children:[]},{level:2,title:"运行过程",slug:"运行过程",children:[]},{level:2,title:"代码测试",slug:"代码测试",children:[]},{level:2,title:"参考文章",slug:"参考文章",children:[]}],filePathRelative:"summary/js-advance/event-loop.md",git:{updatedTime:1636511198e3}}},6404:(n,s,a)=>{a.r(s),a.d(s,{default:()=>d});var e=a(6252);const t=(0,e.uE)('<h1 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h1><p>我们知道，javascript运行是单线程的。这是由于javascript作为浏览器脚本语言，尽可能降低运行的复杂度。比如操作浏览器的 <code>DOM</code>，要是允许多个线程去修改的话，浏览器就不知道以哪个线程为主。</p><p>如果是单线程，遇到多任务的时候就会造成阻塞。比如 <code>ajax</code> 发送请求，我们要等到请求结果返回，才能执行后续代码。而我们发现javascript是非阻塞的，它允许我们为请求注册回调函数，然后继续执行后续的代码，等请求结果返回后再处理回调函数。这内部的实现就是靠javascript的事件循环机制(EventLoop) ,它是让浏览器或者 <code>Node</code> 单线程运行JS而不会阻塞的关键。</p><h2 id="一些术语" tabindex="-1"><a class="header-anchor" href="#一些术语" aria-hidden="true">#</a> 一些术语</h2><p>主线程：运行js代码的主要线程</p><p>执行栈：可以理解为执行js代码时候的环境，执行时入栈，执行后出栈</p><p>同步任务：可以直接在执行栈执行的代码，无需等待</p><p>异步任务：不能直接在执行栈执行，需交给异步模块处理。可分为宏任务 <code>macro task</code> 和微任务 <code>micro task</code>。</p><ul><li><p>宏任务： <code>I/O任务</code>,<code>setTimeout</code>, <code>setInterval</code>, <code>UI Render</code>, <code>setImmediate(Node)</code></p></li><li><p>微任务： <code>process.nextTick(Node)</code>, <code>Promise</code></p></li></ul><p>任务队列： 存放异步任务结果事件的队列，由主线程读取对应事件的回调，放到执行栈执行。</p><h2 id="运行过程" tabindex="-1"><a class="header-anchor" href="#运行过程" aria-hidden="true">#</a> 运行过程</h2><p>主线程进入全局环境开始运行，判断任务是否是异步任务。不是话直接丢进执行栈，执行完出栈。如果是异步任务，交给异步模块处理。</p><img src="http://blog.inoob.xyz/posts/d33ba0d2/2.png" width="500"><p>当异步任务条件达成，比如 <code>I/O</code> 结果返回，定时结束等，会push一个对应的事件到任务队列。入队列的时候会根据任务类型加到对应的队列，比如 <code>micro task</code> 会放到微任务队列 <code>micro queue</code>， <code>macro task</code> 会放到宏任务队列 <code>macro queue</code>。所以任务队列如下：</p><img src="http://blog.inoob.xyz/posts/d33ba0d2/1.png"><p>当主线程执行完执行栈的代码，就会去读取任务队列的事件。读取的时候会优先检测里面的 <code>micro queue</code>有没事件，有就执行对应事件的回调。直到 <code>micro queue</code> 的事件对应的回调都处理完, 才会去读取 <code>macro queue</code> 的事件，在执行宏任务的过程也会产生异步任务，同理它们会放到对应的队列。当这个宏任务执行完后，并不会去执行下一个红任务，而是去检测 <code>micro queue</code> 有没有事件。有就重复上面的过程，没有才执行下一个宏任务。</p><p>一句话，每次事件循环，总优先清理 <code>micro queue</code> 的内容，再去处理 <code>macro queue</code>。</p><h2 id="代码测试" tabindex="-1"><a class="header-anchor" href="#代码测试" aria-hidden="true">#</a> 代码测试</h2><p>执行下面测试代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;time1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>   \n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;time2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>   \n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;start&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>一开始，主线程判断是两个定时的异步任务，记为 <code>st1</code> 和 <code>st2</code>，于是交给异步模块处理，然后再输出start。异步模块会把 <code>st1</code> 和 <code>st2</code> 放到宏任务队列，主线程在输出后执行栈为空，就会去读取 <code>st1</code> 对应的回调执行，输出time1后遇到 <code>Promise</code> 微任务，交给异步模块进入微任务队列。此时主线程读取队列的时候就先读取微任务队列的事件，所以会输出promise1，而不是time2。所以的输出结果为：start time1 promise1 time2 promise2</p><p>操作队列的流程如下图：</p><img src="https://user-gold-cdn.xitu.io/2019/1/18/16860ae5ad02f993?imageslim"><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',24),p={href:"http://www.ruanyifeng.com/blog/2014/10/event-loop.html",target:"_blank",rel:"noopener noreferrer"},o=(0,e.Uk)("JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志"),c={href:"https://juejin.im/post/5c3d8956e51d4511dc72c200",target:"_blank",rel:"noopener noreferrer"},u=(0,e.Uk)("一次弄懂Event Loop（彻底解决此类面试问题） - 掘金"),l={href:"https://mp.weixin.qq.com/s/9_hZX_xWSr3Gd1X_2_WOsA",target:"_blank",rel:"noopener noreferrer"},i=(0,e.Uk)("事件循环机制的那些事"),r={},d=(0,a(3744).Z)(r,[["render",function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[t,(0,e._)("p",null,[(0,e._)("a",p,[o,(0,e.Wm)(a)])]),(0,e._)("p",null,[(0,e._)("a",c,[u,(0,e.Wm)(a)])]),(0,e._)("p",null,[(0,e._)("a",l,[i,(0,e.Wm)(a)])])],64)}]])},3744:(n,s)=>{s.Z=(n,s)=>{for(const[a,e]of s)n[a]=e;return n}}}]);